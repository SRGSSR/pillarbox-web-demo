{"version":3,"file":"quality-menu-rgwqpN9G.js","sources":["../../node_modules/videojs-contrib-quality-menu/dist/videojs-contrib-quality-menu.es.js","../../static/showcases/quality-menu.html?html-proxy&index=0.js","../../static/showcases/quality-menu.html?html-proxy&index=1.js"],"sourcesContent":["/*! @name videojs-contrib-quality-menu @version 1.0.3 @license Apache-2.0 */\nimport videojs from 'video.js';\n\n/**\n * @file quality-menu-item.js\n */\nconst MenuItem = videojs.getComponent('MenuItem');\nconst dom = videojs.dom || videojs;\n\n/**\n * The quality level menu quality\n *\n * @extends MenuItem\n * @class QualityMenuItem\n */\nclass QualityMenuItem extends MenuItem {\n  /**\n   * Creates a QualityMenuItem\n   *\n   * @param {Player|Object} player\n   *        Main Player\n   * @param {Object} [options]\n   *        Options for menu item\n   * @param {number[]} options.levels\n   *        Array of indices mapping to QualityLevels in the QualityLevelList for\n   *        this menu item\n   * @param {string} options.label\n   *        Label for this menu item\n   * @param {string} options.controlText\n   *        control text for this menu item\n   * @param {string} options.subLabel\n   *        sub label text for this menu item\n   * @param {boolean} options.active\n   *        True if the QualityLevelList.selectedIndex is contained in the levels list\n   *        for this menu\n   * @param {boolean} options.selected\n   *        True if this menu item is the selected item in the UI\n   * @param {boolean} options.selectable\n   *        True if this menu item should be selectable in the UI\n   */\n  constructor(player, options = {}) {\n    const selectedOption = options.selected;\n\n    // We need to change options.seleted to options.active because the call to super\n    // causes us to run MenuItem's constructor which calls this.selected(options.selected)\n    // However, for QualityMenuItem, we change the meaning of the parameter to\n    // this.selected() to be what we mean for 'active' which is True if the\n    // QualityLevelList.selectedIndex is contained in the levels list for this menu\n    options.selected = options.active;\n    super(player, options);\n    const qualityLevels = player.qualityLevels();\n    this.levels_ = options.levels;\n    this.selected_ = selectedOption;\n    this.handleQualityChange = this.handleQualityChange.bind(this);\n    this.controlText(options.controlText);\n    this.on(qualityLevels, 'change', this.handleQualityChange);\n    this.on('dispose', () => {\n      this.off(qualityLevels, 'change', this.handleQualityChange);\n    });\n  }\n\n  /**\n   * Create the component's DOM element\n   *\n   * @param {string} [type]\n   *        Element type\n   * @param {Object} [props]\n   *        Element properties\n   * @param {Object} [attrs]\n   *        An object of attributes that should be set on the element\n   * @return {Element}\n   *         The DOM element\n   * @method createEl\n   */\n  createEl(type, props, attrs) {\n    const el = super.createEl(type, props, attrs);\n    const subLabel = dom.createEl('span', {\n      className: 'vjs-quality-menu-item-sub-label',\n      innerHTML: this.localize(this.options_.subLabel || '')\n    });\n    this.subLabel_ = subLabel;\n    if (el) {\n      el.appendChild(subLabel);\n    }\n    return el;\n  }\n\n  /**\n   * Handle a click on the menu item, and set it to selected\n   *\n   * @method handleClick\n   */\n  handleClick() {\n    this.updateSiblings_();\n    const qualityLevels = this.player().qualityLevels();\n    const currentlySelected = qualityLevels.selectedIndex;\n    for (let i = 0, l = qualityLevels.length; i < l; i++) {\n      // do not disable the currently selected quality until the end to prevent\n      // playlist selection from selecting something new until we've enabled/disabled\n      // all the quality levels\n      if (i !== currentlySelected) {\n        qualityLevels[i].enabled = false;\n      }\n    }\n    for (let i = 0, l = this.levels_.length; i < l; i++) {\n      qualityLevels[this.levels_[i]].enabled = true;\n    }\n\n    // Disable the quality level that was selected before the click if it is not\n    // associated with this menu item\n    if (currentlySelected !== -1 && this.levels_.indexOf(currentlySelected) === -1) {\n      qualityLevels[currentlySelected].enabled = false;\n    }\n  }\n\n  /**\n   * Handle a change event from the QualityLevelList\n   *\n   * @method handleQualityChange\n   */\n  handleQualityChange() {\n    const qualityLevels = this.player().qualityLevels();\n    const active = this.levels_.indexOf(qualityLevels.selectedIndex) > -1;\n    this.selected(active);\n  }\n\n  /**\n   * Set this menu item as selected or not\n   *\n   * @param  {boolean} active\n   *         True if the active quality level is controlled by this item\n   * @method selected\n   */\n  selected(active) {\n    if (!this.selectable) {\n      return;\n    }\n    if (this.selected_) {\n      this.addClass('vjs-selected');\n      this.el_.setAttribute('aria-checked', 'true');\n      // aria-checked isn't fully supported by browsers/screen readers,\n      // so indicate selected state to screen reader in the control text.\n      this.controlText(this.localize('{1}, selected', this.localize(this.options_.controlText)));\n      const controlBar = this.player().controlBar;\n      const menuButton = controlBar.getChild('QualityMenuButton');\n      if (!active) {\n        // This menu item is manually selected but the current playing quality level\n        // is NOT associated with this menu item. This can happen if the quality hasnt\n        // changed yet or something went wrong with rendition selection such as failed\n        // server responses for playlists\n        menuButton.addClass('vjs-quality-menu-button-waiting');\n      } else {\n        menuButton.removeClass('vjs-quality-menu-button-waiting');\n      }\n    } else {\n      this.removeClass('vjs-selected');\n      this.el_.setAttribute('aria-checked', 'false');\n      // Indicate un-selected state to screen reader\n      // Note that a space clears out the selected state text\n      this.controlText(this.options_.controlText);\n    }\n  }\n\n  /**\n   * Sets this QualityMenuItem to be selected and deselects the other items\n   *\n   * @method updateSiblings_\n   */\n  updateSiblings_() {\n    const qualityLevels = this.player().qualityLevels();\n    const controlBar = this.player().controlBar;\n    const menuItems = controlBar.getChild('QualityMenuButton').items;\n    for (let i = 0, l = menuItems.length; i < l; i++) {\n      const item = menuItems[i];\n      const active = item.levels_.indexOf(qualityLevels.selectedIndex) > -1;\n      item.selected_ = item === this;\n      item.selected(active);\n    }\n  }\n}\n\n/**\n * @file quality-menu-button.js\n */\nconst MenuButton = videojs.getComponent('MenuButton');\n\n/**\n * Checks whether any of the QualityLevels in a QualityLevelList have resolution information\n *\n * @param {QualityLevelList} qualityLevelList\n *        The list of QualityLevels\n * @return {boolean}\n *         True if any levels have resolution information, false if none have\n * @function hasResolutionInfo\n */\nconst hasResolutionInfo = function (qualityLevelList) {\n  return Array.from(qualityLevelList).some(level => level.height);\n};\n\n/**\n * Determines the appropriate sub label for the given lines of resolution\n *\n * @param {number} lines\n *        The horizontal lines of resolution\n * @return {string}\n *         sub label for given resolution\n * @function getSubLabel\n */\nconst getSubLabel = function (lines) {\n  if (lines >= 2160) {\n    return '4K';\n  }\n  if (lines >= 720) {\n    return 'HD';\n  }\n  return '';\n};\n\n/**\n * The component for controlling the quality menu\n *\n * @extends MenuButton\n * @class QualityMenuButton\n */\nclass QualityMenuButton extends MenuButton {\n  /**\n   * Creates a QualityMenuButton\n   *\n   * @param {Player|Object} player\n   *        Main Player\n   * @param {Object} [options]\n   *        Options for QualityMenuButton\n   */\n  constructor(player, options = {}) {\n    super(player, options);\n    this.el_.setAttribute('aria-label', this.localize('Quality Levels'));\n    this.controlText('Quality Levels');\n    if (!player.options().experimentalSvgIcons) {\n      this.$('.vjs-icon-placeholder').classList.add('vjs-icon-cog');\n    }\n    this.setIcon('cog');\n    this.qualityLevels_ = player.qualityLevels();\n    this.update = this.update.bind(this);\n    this.hide = this.hide.bind(this);\n    this.handleQualityChange_ = this.handleQualityChange_.bind(this);\n    this.firstChangeHandler_ = this.firstChangeHandler_.bind(this);\n    this.enableDefaultResolution_ = this.enableDefaultResolution_.bind(this);\n    this.on(this.qualityLevels_, 'addqualitylevel', this.update);\n    this.on(this.qualityLevels_, 'removequalitylevel', this.update);\n    this.on(this.qualityLevels_, 'change', this.handleQualityChange_);\n\n    // TODO: Remove this and the `defaultResolution` option once videojs/http-streaming supports comparable functionality\n    this.one(this.qualityLevels_, 'change', this.firstChangeHandler_);\n    player.on('adstart', this.hide);\n    player.on(['adend', 'adtimeout'], this.update);\n    this.update();\n    this.on('dispose', () => {\n      this.off(this.qualityLevels_, 'addqualitylevel', this.update);\n      this.off(this.qualityLevels_, 'removequalitylevel', this.update);\n      this.off(this.qualityLevels_, 'change', this.handleQualityChange_);\n      this.off(this.qualityLevels_, 'change', this.firstChangeHandler_);\n      player.off('adstart', this.hide);\n      player.off(['adend', 'adtimeout'], this.update);\n      player.off('loadedmetadata', this.enableDefaultResolution_);\n    });\n  }\n\n  /**\n   * Allow sub components to stack CSS class names\n   *\n   * @return {string}\n   *         The constructed class name\n   * @method buildWrapperCSSClass\n   */\n  buildWrapperCSSClass() {\n    return `vjs-quality-menu-wrapper ${super.buildWrapperCSSClass()}`;\n  }\n\n  /**\n   * Allow sub components to stack CSS class names\n   *\n   * @return {string}\n   *         The constructed class name\n   * @method buildCSSClass\n   */\n  buildCSSClass() {\n    return `vjs-quality-menu-button ${super.buildCSSClass()}`;\n  }\n\n  /**\n   * Create the list of menu items.\n   *\n   * @return {Array}\n   *         The list of menu items\n   * @method createItems\n   */\n  createItems() {\n    const items = [];\n    if (!(this.qualityLevels_ && this.qualityLevels_.length)) {\n      return items;\n    }\n    let groups;\n    if (this.options_.useResolutionLabels && hasResolutionInfo(this.qualityLevels_)) {\n      groups = this.groupByResolution_();\n      this.addClass('vjs-quality-menu-button-use-resolution');\n    } else {\n      groups = this.groupByBitrate_();\n      this.removeClass('vjs-quality-menu-button-use-resolution');\n    }\n\n    // if there is only 1 or 0 menu items, we should just return an empty list so\n    // the ui does not appear when there are no options. We consider 1 to be no options\n    // since Auto will have the same behavior as selecting the only other option,\n    // so it is as effective as not having any options.\n    if (groups.length <= 1) {\n      return [];\n    }\n    groups.forEach(group => {\n      if (group.levels.length) {\n        group.selectable = true;\n        items.push(new QualityMenuItem(this.player(), group));\n      }\n    });\n\n    // Add the Auto menu item\n    const auto = new QualityMenuItem(this.player(), {\n      levels: Array.prototype.map.call(this.qualityLevels_, (level, i) => i),\n      label: 'Auto',\n      controlText: 'Auto',\n      active: true,\n      selected: true,\n      selectable: true\n    });\n    this.autoMenuItem_ = auto;\n    items.push(auto);\n    return items;\n  }\n\n  /**\n   * Group quality levels by lines of resolution\n   *\n   * @return {Array}\n   *         Array of each group\n   * @method groupByResolution_\n   */\n  groupByResolution_() {\n    const groups = {};\n    const order = [];\n    for (let i = 0, l = this.qualityLevels_.length; i < l; i++) {\n      const level = this.qualityLevels_[i];\n      const active = this.qualityLevels_.selectedIndex === i;\n      const lines = level.height;\n\n      // Do not include an audio-only level\n      if (!lines) {\n        continue;\n      }\n      let label;\n      if (this.options_.resolutionLabelBitrates) {\n        const kbRate = Math.round(level.bitrate / 1000);\n        label = `${lines}p @ ${kbRate} kbps`;\n      } else {\n        label = lines + 'p';\n      }\n      if (!groups[label]) {\n        const subLabel = getSubLabel(lines);\n        groups[label] = {\n          levels: [],\n          label,\n          controlText: label,\n          subLabel\n        };\n        order.push({\n          label,\n          lines\n        });\n      }\n      if (active) {\n        groups[label].active = true;\n      }\n      groups[label].levels.push(i);\n    }\n\n    // Sort from High to Low\n    order.sort((a, b) => b.lines - a.lines);\n    const sortedGroups = [];\n    order.forEach(group => {\n      sortedGroups.push(groups[group.label]);\n    });\n    return sortedGroups;\n  }\n\n  /**\n   * Group quality levels by bitrate into SD and HD buckets\n   *\n   * @return {Array}\n   *         Array of each group\n   * @method groupByBitrate_\n   */\n  groupByBitrate_() {\n    // groups[0] for HD, groups[1] for SD, since we want sorting from high to low\\\n    const groups = [{\n      levels: [],\n      label: 'HD',\n      controlText: 'High Definition'\n    }, {\n      levels: [],\n      label: 'SD',\n      controlText: 'Standard Definition'\n    }];\n    for (let i = 0, l = this.qualityLevels_.length; i < l; i++) {\n      const level = this.qualityLevels_[i];\n      const active = this.qualityLevels_.selectedIndex === i;\n      let group;\n      if (level.bitrate < this.options_.sdBitrateLimit) {\n        group = groups[1];\n      } else {\n        group = groups[0];\n      }\n      if (active) {\n        group.active = true;\n      }\n      group.levels.push(i);\n    }\n    if (!groups[0].levels.length || !groups[1].levels.length) {\n      // Either HD or SD do not have any quality levels, we should just return an empty\n      // list so the ui does not appear when there are no options. We consider 1\n      // to be no options since Auto will have the same behavior as selecting the only\n      // other option, so it is as effective as not having any options.\n      return [];\n    }\n    return groups;\n  }\n\n  /**\n   * Handle a change event from the QualityLevelList\n   *\n   * @method handleQualityChange_\n   */\n  handleQualityChange_() {\n    const selected = this.qualityLevels_[this.qualityLevels_.selectedIndex];\n    const useResolution = this.options_.useResolutionLabels && hasResolutionInfo(this.qualityLevels_);\n    let subLabel = '';\n    if (selected) {\n      if (useResolution) {\n        subLabel = getSubLabel(selected.height);\n      } else if (selected.bitrate >= this.options_.sdBitrateLimit) {\n        subLabel = 'HD';\n      }\n    }\n    if (subLabel === 'HD') {\n      this.addClass('vjs-quality-menu-button-HD-flag');\n      this.removeClass('vjs-quality-menu-button-4K-flag');\n    } else if (subLabel === '4K') {\n      this.removeClass('vjs-quality-menu-button-HD-flag');\n      this.addClass('vjs-quality-menu-button-4K-flag');\n    } else {\n      this.removeClass('vjs-quality-menu-button-HD-flag');\n      this.removeClass('vjs-quality-menu-button-4K-flag');\n    }\n    if (this.autoMenuItem_) {\n      if (this.autoMenuItem_.manuallySelected_ && selected) {\n        // auto mode, update the sub label\n        this.autoMenuItem_.subLabel_.innerHTML = this.localize(subLabel);\n      } else {\n        this.autoMenuItem_.subLabel_.innerHTML = '';\n      }\n    }\n  }\n\n  /**\n   * Enable the `defaultResolution`, if specified\n   *\n   * @method enableDefaultResolution_\n   */\n  enableDefaultResolution_() {\n    const defaultResolution = this.options_.defaultResolution;\n    for (let i = 0; i < this.items.length; i++) {\n      if (this.items[i].options_.label.indexOf(defaultResolution) !== -1) {\n        this.items[i].handleClick();\n      }\n    }\n  }\n\n  /**\n   * Handle the first change event in order to enable the `defaultResolution`, if specified\n   *\n   * @method firstChangeHandler_\n   */\n  firstChangeHandler_() {\n    // If we haven't loaded metadata yet and we expect it before playback is initiated, wait to perform the quality switch.\n    // Doing so before 'loadedmetadata' can result in cancelling requests for init segments required for the browser to fire 'loadedmetadata'.\n    if (this.player_.readyState() < 1 && this.player_.preload() !== 'none') {\n      this.player_.one('loadedmetadata', this.enableDefaultResolution_);\n      return;\n    }\n    this.enableDefaultResolution_();\n  }\n}\nvideojs.registerComponent('QualityMenuButton', QualityMenuButton);\n\nvar version = \"1.0.3\";\n\n// Default options for the plugin.\nconst defaults = {\n  sdBitrateLimit: 2000000,\n  useResolutionLabels: true,\n  resolutionLabelBitrates: false,\n  defaultResolution: 'none'\n};\n\n/**\n * Function to invoke when the player is ready.\n *\n * This is a great place for your plugin to initialize itself. When this\n * function is called, the player will have its DOM and child components\n * in place.\n *\n * @function onPlayerReady\n * @param    {Player} player\n *           A Video.js player.\n * @param    {Object} [options={}]\n *           An object of options left to the plugin author to define.\n * @return {Function} disposal function for re initialization\n */\nconst onPlayerReady = (player, options) => {\n  player.addClass('vjs-quality-menu');\n  const controlBar = player.getChild('controlBar');\n  const button = controlBar.addChild('QualityMenuButton', options, controlBar.children_.length - 2);\n  return function () {\n    player.removeClass('vjs-quality-menu');\n    controlBar.removeChild(button);\n    button.dispose();\n  };\n};\n\n/**\n * Main entry point for the plugin\n *\n * @function initPlugin\n * @param {Player} player a reference to a videojs Player instance\n * @param {Object} [options] an object with plugin options\n */\nconst initPlugin = function (player, options) {\n  if (typeof player.qualityLevels !== 'undefined') {\n    // call qualityLevels to initialize it in case it hasnt been initialized yet\n    player.qualityLevels();\n    let disposeFn = () => {};\n    player.ready(() => {\n      disposeFn = onPlayerReady(player, options);\n      player.on('loadstart', () => {\n        disposeFn();\n        disposeFn = onPlayerReady(player, options);\n      });\n    });\n\n    // reinitialization is no-op for now\n    player.qualityMenu = () => {};\n    player.qualityMenu.VERSION = version;\n  }\n};\n\n/**\n * A video.js plugin.\n *\n * In the plugin function, the value of `this` is a video.js `Player`\n * instance. You cannot rely on the player being in a \"ready\" state here,\n * depending on how the plugin is invoked. This may or may not be important\n * to you; if not, remove the wait for \"ready\"!\n *\n * @function qualityMenu\n * @param    {Object} [options={}]\n *           An object of options left to the plugin author to define.\n */\nconst qualityMenu = function (options) {\n  initPlugin(this, videojs.obj.merge(defaults, options));\n};\n\n// Register the plugin with video.js.\nvideojs.registerPlugin('qualityMenu', qualityMenu);\n\n// Include the version number.\nqualityMenu.VERSION = version;\n\nexport { qualityMenu as default };\n","\n  import pillarbox from '@srgssr/pillarbox-web';\n  // Import the quality menu plugin\n  import 'videojs-contrib-quality-menu';\n\n  // Create a pillarbox player instance with the quality menu plugin\n  const player = pillarbox('video-element-id', { plugins: { qualityMenu: true } });\n\n  // Load the video source\n  player.src({ src: 'urn:srf:video:593535b2-87c0-433a-8d2c-baf819233df1', type: 'srgssr/urn' });\n","\n  import pillarbox from '@srgssr/pillarbox-web';\n  import '../../src/layout/header/core-demo-header-component.js';\n\n  document.querySelector('#close-btn').addEventListener('click', () => {\n    window.close();\n  });\n\n  window.pillarbox = pillarbox;\n"],"names":["MenuItem","videojs","dom","QualityMenuItem","player","options","selectedOption","qualityLevels","type","props","attrs","el","subLabel","currentlySelected","i","active","menuButton","menuItems","l","item","MenuButton","hasResolutionInfo","qualityLevelList","level","getSubLabel","lines","QualityMenuButton","items","groups","group","auto","order","label","kbRate","a","b","sortedGroups","selected","useResolution","defaultResolution","version","defaults","onPlayerReady","controlBar","button","initPlugin","disposeFn","qualityMenu","pillarbox"],"mappings":"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","x_google_ignoreList":[0]}